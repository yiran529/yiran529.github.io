<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="“为什么 import 总是报错 ModuleNotFoundError？”“为什么我的代码里会出现 ImportError: cannot import name 的循环依赖？”“__init__.py 到底需不需要写？” 对于初级开发者，import 只是一个语法；但对于进阶工程师，理解 Python 的模块系统（Module System）是构建大型、可维护项目的基石。本文将从底层原理出发，">
<meta property="og:type" content="article">
<meta property="og:title" content="硬核解析：Python 模块化编程与 Import 机制的底层逻辑">
<meta property="og:url" content="http://example.com/2025/12/21/import/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="“为什么 import 总是报错 ModuleNotFoundError？”“为什么我的代码里会出现 ImportError: cannot import name 的循环依赖？”“__init__.py 到底需不需要写？” 对于初级开发者，import 只是一个语法；但对于进阶工程师，理解 Python 的模块系统（Module System）是构建大型、可维护项目的基石。本文将从底层原理出发，">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-12-21T08:30:00.000Z">
<meta property="article:modified_time" content="2025-12-21T07:41:50.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Architecture">
<meta property="article:tag" content="Best Practices">
<meta property="article:tag" content="Engineering">
<meta property="article:tag" content="Import System">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2025/12/21/import/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>硬核解析：Python 模块化编程与 Import 机制的底层逻辑 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/21/import/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          硬核解析：Python 模块化编程与 Import 机制的底层逻辑
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-12-21 16:30:00 / Modified: 15:41:50" itemprop="dateCreated datePublished" datetime="2025-12-21T16:30:00+08:00">2025-12-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Python进阶</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">架构设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>“为什么 <code>import</code> 总是报错 <code>ModuleNotFoundError</code>？”<br>“为什么我的代码里会出现 <code>ImportError: cannot import name</code> 的循环依赖？”<br>“<code>__init__.py</code> 到底需不需要写？”</p>
<p>对于初级开发者，<code>import</code> 只是一个语法；但对于进阶工程师，理解 Python 的模块系统（Module System）是构建大型、可维护项目的基石。本文将从底层原理出发，拆解 <code>import</code> 的执行流程，并给出工程化的最佳实践。</p>
<span id="more"></span>
<h2 id="1-基础概念拆解：模块与包的本质"><a href="#1-基础概念拆解：模块与包的本质" class="headerlink" title="1. 基础概念拆解：模块与包的本质"></a>1. 基础概念拆解：模块与包的本质</h2><p>在 Python 的世界里，一切皆对象，模块也不例外。</p>
<h3 id="1-1-什么是模块-Module-？"><a href="#1-1-什么是模块-Module-？" class="headerlink" title="1.1 什么是模块 (Module)？"></a>1.1 什么是模块 (Module)？</h3><p><strong>本质</strong>：一个包含 Python 定义和语句的 <code>.py</code> 文件。<br>文件名就是模块名（不含后缀）。例如，文件 <code>utils.py</code> 对应的模块名是 <code>utils</code>。</p>
<h3 id="1-2-什么是包-Package-？"><a href="#1-2-什么是包-Package-？" class="headerlink" title="1.2 什么是包 (Package)？"></a>1.2 什么是包 (Package)？</h3><p><strong>本质</strong>：一个包含 <code>__init__.py</code> 文件的<strong>目录</strong>。<br>包允许我们将模块组织成层级结构（Namespace）。虽然 Python 3.3+ 引入了“命名空间包”（Namespace Packages），允许省略 <code>__init__.py</code>，但在工程实践中，为了明确包的边界和初始化逻辑，<strong>保留 <code>__init__.py</code> 依然是标准规范</strong>。</p>
<h3 id="1-3-为什么要模块化？"><a href="#1-3-为什么要模块化？" class="headerlink" title="1.3 为什么要模块化？"></a>1.3 为什么要模块化？</h3><p>设计模块系统的初衷主要有两点：</p>
<ol>
<li><strong>命名空间隔离 (Namespace Isolation)</strong>：避免变量名冲突。<code>A.utils.save()</code> 和 <code>B.utils.save()</code> 互不干扰。</li>
<li><strong>代码复用与解耦</strong>：将功能拆分为独立单元，便于维护和测试。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">项目根目录</span><br><span class="line">└── my_package                  # 包</span><br><span class="line">    ├── __init__.py             # 包标识</span><br><span class="line">    ├── core.py                 # 模块</span><br><span class="line">    ├── utils.py                # 模块</span><br><span class="line">    └── sub_package             # 子包</span><br><span class="line">        ├── __init__.py</span><br><span class="line">        └── helper.py</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-深入底层：Import-机制是如何工作的？"><a href="#2-深入底层：Import-机制是如何工作的？" class="headerlink" title="2. 深入底层：Import 机制是如何工作的？"></a>2. 深入底层：Import 机制是如何工作的？</h2><p>当你执行 <code>import numpy</code> 时，Python 解释器并不是简单地读取文件，背后发生了一系列复杂的动作。</p>
<h3 id="2-1-Import-的三步曲"><a href="#2-1-Import-的三步曲" class="headerlink" title="2.1 Import 的三步曲"></a>2.1 Import 的三步曲</h3><p>Python 的导入过程大致分为三个阶段：</p>
<ol>
<li><strong>查找 (Find)</strong>：<br>解释器会在 <code>sys.path</code> 包含的目录列表中，按顺序查找名为 <code>numpy</code> 的模块或包。</li>
<li><strong>加载与编译 (Load &amp; Compile)</strong>：<ul>
<li>如果找到的是 <code>.py</code> 文件，解释器会将其编译成字节码（<code>.pyc</code>）。</li>
<li><strong>关键点</strong>：解释器会执行模块内的<strong>所有顶级语句</strong>（Top-level statements）。这就是为什么在模块顶层写 <code>print(&quot;hello&quot;)</code> 会在导入时打印的原因。</li>
</ul>
</li>
<li><strong>绑定 (Bind)</strong>：<ul>
<li>创建一个 <code>module</code> 对象。</li>
<li>将该对象存储在全局缓存 <code>sys.modules</code> 中。</li>
<li>在当前命名空间中绑定变量名（如 <code>numpy</code>）。</li>
</ul>
</li>
</ol>
<h3 id="2-2-核心组件：sys-modules-与-sys-path"><a href="#2-2-核心组件：sys-modules-与-sys-path" class="headerlink" title="2.2 核心组件：sys.modules 与 sys.path"></a>2.2 核心组件：sys.modules 与 sys.path</h3><ul>
<li><p><strong><code>sys.modules</code> (缓存机制)</strong>：<br>这是一个全局字典，缓存了所有已加载的模块。</p>
<ul>
<li><strong>原理</strong>：每次 import 前，Python 都会先检查 <code>sys.modules</code>。如果存在，直接返回缓存对象。</li>
<li><strong>意义</strong>：这就是为什么多次 <code>import</code> 同一个模块，代码只会执行一次，且效率极高。</li>
</ul>
</li>
<li><p><strong><code>sys.path</code> (搜索路径)</strong>：<br>这是一个列表，决定了 Python 去哪里找模块。查找顺序如下：</p>
<ol>
<li><strong>当前脚本所在目录</strong>（或当前工作目录）。</li>
<li><strong>PYTHONPATH</strong> 环境变量（如果设置了）。</li>
<li><strong>标准库路径</strong>。</li>
<li><strong>site-packages</strong>（第三方库路径）。</li>
</ol>
</li>
</ul>
<h3 id="2-3-绝对导入-vs-相对导入"><a href="#2-3-绝对导入-vs-相对导入" class="headerlink" title="2.3 绝对导入 vs 相对导入"></a>2.3 绝对导入 vs 相对导入</h3><p>这是新手最容易踩坑的地方。</p>
<ul>
<li><p><strong>绝对导入 (Absolute Import)</strong>：<br>从项目根目录（或 <code>sys.path</code>）开始写完整路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package.sub_package <span class="keyword">import</span> helper</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>推荐</strong>：清晰、无歧义，是 PEP 8 推荐的方式。</li>
</ul>
</li>
<li><p><strong>相对导入 (Relative Import)</strong>：<br>基于当前文件位置，使用 <code>.</code> 表示当前目录，<code>..</code> 表示上级目录。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 my_package/core.py 中</span></span><br><span class="line"><span class="keyword">from</span> .utils <span class="keyword">import</span> some_func  <span class="comment"># 同级目录</span></span><br><span class="line"><span class="keyword">from</span> ..sub_package <span class="keyword">import</span> helper <span class="comment"># 上级目录的兄弟包</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>陷阱</strong>：相对导入<strong>只能在包内部使用</strong>。如果你直接运行脚本 <code>python core.py</code>，且脚本内包含相对导入，会报错 <code>ImportError: attempted relative import with no known parent package</code>。这是因为直接运行脚本时，<code>__name__</code> 是 <code>__main__</code>，Python 此时不知道它属于哪个包。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-Package-Module-管理最佳实践"><a href="#3-Package-Module-管理最佳实践" class="headerlink" title="3. Package/Module 管理最佳实践"></a>3. Package/Module 管理最佳实践</h2><h3 id="3-1-目录结构设计：Src-Layout"><a href="#3-1-目录结构设计：Src-Layout" class="headerlink" title="3.1 目录结构设计：Src Layout"></a>3.1 目录结构设计：Src Layout</h3><p>在上一篇关于 Python 包管理的文章中，我们提到了 <code>src layout</code>。这里给出一个通过长期工程实践验证的标准目录树：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">my_project/</span><br><span class="line">├── pyproject.toml       # 依赖与打包配置</span><br><span class="line">├── README.md</span><br><span class="line">├── src/                 # 源码层，避免 import 歧义</span><br><span class="line">│   └── my_package/      # 顶层包</span><br><span class="line">│       ├── __init__.py  # 暴露公共接口</span><br><span class="line">│       ├── __main__.py  # 允许 python -m my_package 运行</span><br><span class="line">│       ├── core/        # 核心逻辑</span><br><span class="line">│       │   ├── __init__.py</span><br><span class="line">│       │   └── engine.py</span><br><span class="line">│       └── utils/       # 工具类</span><br><span class="line">│           ├── __init__.py</span><br><span class="line">│           └── string_utils.py</span><br><span class="line">└── tests/               # 测试代码</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    └── test_core.py</span><br></pre></td></tr></table></figure>
<h3 id="3-2-优雅的导入写法"><a href="#3-2-优雅的导入写法" class="headerlink" title="3.2 优雅的导入写法"></a>3.2 优雅的导入写法</h3><ul>
<li><p><strong>拒绝 <code>from module import *</code></strong>：<br>这会污染当前的命名空间，覆盖已有的变量，且让代码难以阅读（不知道变量是从哪来的）。</p>
<ul>
<li><em>Bad:</em> <code>from math import *</code></li>
<li><em>Good:</em> <code>from math import sqrt, ceil</code></li>
</ul>
</li>
<li><p><strong>合理使用 <code>__all__</code></strong>：<br>如果你必须支持 <code>from *</code>，请在模块中定义 <code>__all__</code> 列表，显式声明哪些变量是可以被导出的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils.py</span></span><br><span class="line">__all__ = [<span class="string">&#x27;public_func&#x27;</span>] </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">public_func</span>(): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_private_func</span>(): <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-3-循环导入-Circular-Imports-的噩梦"><a href="#3-3-循环导入-Circular-Imports-的噩梦" class="headerlink" title="3.3 循环导入 (Circular Imports) 的噩梦"></a>3.3 循环导入 (Circular Imports) 的噩梦</h3><p><strong>场景</strong>：模块 A 导入 模块 B，模块 B 又导入 模块 A。<br><strong>报错</strong>：通常是 <code>ImportError: cannot import name &#39;X&#39;</code> 或 <code>AttributeError</code>。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>架构重构 (推荐)</strong>：提取公共部分到第三个模块 C，让 A 和 B 都导入 C。</li>
<li><strong>延迟导入</strong>：将 import 语句移到函数/方法内部，而不是放在文件顶层。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># module_a.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_a</span>():</span><br><span class="line">    <span class="keyword">from</span> module_b <span class="keyword">import</span> func_b  <span class="comment"># 运行时才导入</span></span><br><span class="line">    func_b()</span><br></pre></td></tr></table></figure></li>
<li><strong>类型检查导入</strong>：如果只是为了 Type Hint 导致的循环依赖，使用 <code>TYPE_CHECKING</code>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TYPE_CHECKING</span><br><span class="line"><span class="keyword">if</span> TYPE_CHECKING:</span><br><span class="line">    <span class="keyword">from</span> module_b <span class="keyword">import</span> ComplexClass</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="4-工程化落地建议"><a href="#4-工程化落地建议" class="headerlink" title="4. 工程化落地建议"></a>4. 工程化落地建议</h2><h3 id="4-1-init-py-的进阶用法：Facade-模式"><a href="#4-1-init-py-的进阶用法：Facade-模式" class="headerlink" title="4.1 __init__.py 的进阶用法：Facade 模式"></a>4.1 <code>__init__.py</code> 的进阶用法：Facade 模式</h3><p><code>__init__.py</code> 不仅仅是空文件，它是包的“门面”。我们可以用它来简化用户的导入路径。</p>
<p>假设结构是 <code>my_package/core/engine.py</code>，里面有个类 <code>MyEngine</code>。<br>如果不处理，用户需要写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package.core.engine <span class="keyword">import</span> MyEngine</span><br></pre></td></tr></table></figure></p>
<p>我们可以在 <code>my_package/__init__.py</code> 中写入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my_package/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> .core.engine <span class="keyword">import</span> MyEngine</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&quot;MyEngine&quot;</span>]</span><br></pre></td></tr></table></figure><br>这样用户只需要写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> MyEngine</span><br></pre></td></tr></table></figure></p>
<h3 id="4-2-main-py-的妙用"><a href="#4-2-main-py-的妙用" class="headerlink" title="4.2 __main__.py 的妙用"></a>4.2 <code>__main__.py</code> 的妙用</h3><p>如果在包根目录下创建 <code>__main__.py</code>，用户就可以通过 <code>python -m my_package</code> 来运行这个包。这在编写命令行工具（CLI）时非常有用。</p>
<h3 id="4-3-动态导入-Dynamic-Import"><a href="#4-3-动态导入-Dynamic-Import" class="headerlink" title="4.3 动态导入 (Dynamic Import)"></a>4.3 动态导入 (Dynamic Import)</h3><p>有时我们需要根据配置文件字符串来导入模块（例如插件系统）。这时不要用 <code>exec</code>，要用标准库 <code>importlib</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line">module_name = <span class="string">&quot;os&quot;</span>  <span class="comment"># 可以是从配置文件读出来的字符串</span></span><br><span class="line">module = importlib.import_module(module_name)</span><br><span class="line"><span class="built_in">print</span>(module.getcwd())</span><br></pre></td></tr></table></figure>
<h3 id="4-4-常见反模式-Anti-Patterns"><a href="#4-4-常见反模式-Anti-Patterns" class="headerlink" title="4.4 常见反模式 (Anti-Patterns)"></a>4.4 常见反模式 (Anti-Patterns)</h3><ol>
<li><strong>在代码中硬编码 <code>sys.path.append(...)</code></strong>：<br>这是一种极其脆弱的做法，导致代码移植性极差。请使用 <code>PYTHONPATH</code> 环境变量或正确安装包（<code>pip install -e .</code>）来解决路径问题。</li>
<li><strong>过度嵌套</strong>：<br><code>package.sub.sub.sub.utils</code>。Python 之禅说 “Flat is better than nested”。尽量保持包结构扁平。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>理解 Python 的 <code>import</code> 机制，意味着理解了 Python 如何组织代码、如何管理内存（<code>sys.modules</code>）以及如何查找依赖。</p>
<ul>
<li><strong>原则</strong>：保持明确（Explicit is better than implicit）。</li>
<li><strong>规范</strong>：使用 <code>src</code> 结构，保留 <code>__init__.py</code>。</li>
<li><strong>技巧</strong>：利用 <code>__init__.py</code> 封装接口，利用 <code>importlib</code> 处理动态需求。</li>
</ul>
<p>掌握这些，你的 Python 项目架构将变得稳固而优雅。</p>
<h2 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h2><p>为了让你直观地验证<strong>第二节（Import机制底层）</strong>和<strong>第四节（工程化实践）</strong>的内容，我设计了一个微型实验项目。</p>
<p>你可以按照以下目录结构创建文件，然后运行脚本，亲眼看到 <code>sys.modules</code> 的缓存机制、<code>__init__.py</code> 的门面作用以及 <code>__main__.py</code> 的运行逻辑。</p>
<h3 id="1-实验准备：搭建目录结构"><a href="#1-实验准备：搭建目录结构" class="headerlink" title="1. 实验准备：搭建目录结构"></a>1. 实验准备：搭建目录结构</h3><p>请在本地创建一个文件夹 <code>import_lab</code>，并在其中创建以下文件结构：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import_lab/                # 项目根目录</span><br><span class="line">├── my_package/            # 自定义包</span><br><span class="line">│   ├── __init__.py        # 【验证第四节】门面模式</span><br><span class="line">│   ├── __main__.py        # 【验证第四节】CLI入口</span><br><span class="line">│   └── core.py            # 核心模块</span><br><span class="line">└── verify_script.py       # 【验证第二节】测试脚本</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-编写代码"><a href="#2-编写代码" class="headerlink" title="2. 编写代码"></a>2. 编写代码</h3><h4 id="A-my-package-core-py"><a href="#A-my-package-core-py" class="headerlink" title="A. my_package/core.py"></a>A. <code>my_package/core.py</code></h4><p>我们在模块顶层加个 print，用来验证模块是什么时候被“加载与编译”的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my_package/core.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; [Core] 正在加载 core.py (字节码编译执行中)...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heavy_logic</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;核心逻辑执行完毕&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="B-my-package-init-py"><a href="#B-my-package-init-py" class="headerlink" title="B. my_package/__init__.py"></a>B. <code>my_package/__init__.py</code></h4><p><strong>验证第四节</strong>：利用 <code>__init__.py</code> 导出子模块功能（Facade 模式），并打印初始化信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my_package/__init__.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; [Package] 正在初始化 my_package 包...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【第四节实践】门面模式：从子模块导入，方便用户直接使用 my_package.heavy_logic</span></span><br><span class="line"><span class="keyword">from</span> .core <span class="keyword">import</span> heavy_logic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义导出列表</span></span><br><span class="line">__all__ = [<span class="string">&#x27;heavy_logic&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h4 id="C-my-package-main-py"><a href="#C-my-package-main-py" class="headerlink" title="C. my_package/__main__.py"></a>C. <code>my_package/__main__.py</code></h4><p><strong>验证第四节</strong>：允许通过 <code>python -m</code> 运行包。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my_package/__main__.py</span></span><br><span class="line"><span class="keyword">from</span> .core <span class="keyword">import</span> heavy_logic</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;&gt;&gt;&gt; [Main] 正在以脚本方式运行 my_package&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;&gt;&gt;&gt; 接收到的参数: <span class="subst">&#123;sys.argv&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;&gt;&gt;&gt; 执行结果: <span class="subst">&#123;heavy_logic()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="D-verify-script-py-核心测试脚本"><a href="#D-verify-script-py-核心测试脚本" class="headerlink" title="D. verify_script.py (核心测试脚本)"></a>D. <code>verify_script.py</code> (核心测试脚本)</h4><p><strong>验证第二节</strong>：<code>sys.modules</code> 缓存、<code>sys.path</code> 查找、动态导入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=== 实验开始 ===&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 【验证第二节】查看搜索路径</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n1. sys.path 第一个路径是: <span class="subst">&#123;sys.path[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># (通常是当前脚本所在目录，证明了Python优先查找当前目录)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 【验证第二节】检查缓存 (此时还没导入 my_package)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;2. 导入前 check缓存: &#x27;my_package&#x27; in sys.modules? <span class="subst">&#123;<span class="string">&#x27;my_package&#x27;</span> <span class="keyword">in</span> sys.modules&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 【验证第二节】第一次导入</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- 执行 import my_package ---&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> my_package</span><br><span class="line"><span class="comment"># 预期输出：会依次打印 [Package] 和 [Core] 的 print 语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 【验证第二节】缓存机制生效</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- 执行 import my_package (第二次) ---&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> my_package</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   (如果没有看到 [Package] 或 [Core] 的打印，说明直接使用了 sys.modules 缓存)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 【验证第四节】门面模式调用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n3. 门面模式调用: <span class="subst">&#123;my_package.heavy_logic()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># (本来应该写 my_package.core.heavy_logic，但在 __init__ 里简化了)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 【验证第四节】动态导入 (importlib)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n4. 动态导入实验:&quot;</span>)</span><br><span class="line">pkg_name = <span class="string">&quot;my_package&quot;</span> <span class="comment"># 模拟从配置文件读取字符串</span></span><br><span class="line">mod = importlib.import_module(pkg_name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;   动态导入成功: <span class="subst">&#123;mod&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n=== 实验结束 ===&quot;</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-运行验证"><a href="#3-运行验证" class="headerlink" title="3. 运行验证"></a>3. 运行验证</h3><p>请打开终端（Terminal），进入 <code>import_lab</code> 目录，分别运行以下两条命令。</p>
<h4 id="实验一：验证-Import-机制与工程封装"><a href="#实验一：验证-Import-机制与工程封装" class="headerlink" title="实验一：验证 Import 机制与工程封装"></a>实验一：验证 Import 机制与工程封装</h4><p>运行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python verify_script.py</span><br></pre></td></tr></table></figure></p>
<p><strong>预期输出与原理解析：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">=== 实验开始 ===</span><br><span class="line"></span><br><span class="line">1. sys.path 第一个路径是: .../import_lab</span><br><span class="line"># 验证原理：Python 自动将脚本所在目录加入 sys.path，所以能找到 my_package</span><br><span class="line"></span><br><span class="line">2. 导入前 check缓存: &#x27;my_package&#x27; in sys.modules? False</span><br><span class="line"></span><br><span class="line">--- 执行 import my_package ---</span><br><span class="line">&gt;&gt;&gt; [Package] 正在初始化 my_package 包...</span><br><span class="line">&gt;&gt;&gt; [Core] 正在加载 core.py (字节码编译执行中)...</span><br><span class="line"># 验证原理：这是“加载与编译”阶段，顶层代码被执行。</span><br><span class="line"></span><br><span class="line">--- 执行 import my_package (第二次) ---</span><br><span class="line">   (如果没有看到...说明使用了缓存)</span><br><span class="line"># 验证原理：sys.modules 检测到已存在 key，跳过加载。</span><br><span class="line"></span><br><span class="line">3. 门面模式调用: 核心逻辑执行完毕</span><br><span class="line"># 验证原理：__init__.py 里的 from .core import ... 生效。</span><br><span class="line"></span><br><span class="line">4. 动态导入实验:</span><br><span class="line">   动态导入成功: &lt;module &#x27;my_package&#x27; from ...&gt;</span><br></pre></td></tr></table></figure>
<h4 id="实验二：验证-main-py-CLI-入口"><a href="#实验二：验证-main-py-CLI-入口" class="headerlink" title="实验二：验证 __main__.py (CLI 入口)"></a>实验二：验证 <code>__main__.py</code> (CLI 入口)</h4><p>运行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m my_package hello world</span><br></pre></td></tr></table></figure></p>
<p><strong>预期输出与原理解析：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [Package] 正在初始化 my_package 包...</span><br><span class="line">&gt;&gt;&gt; [Core] 正在加载 core.py (字节码编译执行中)...</span><br><span class="line">&gt;&gt;&gt; [Main] 正在以脚本方式运行 my_package</span><br><span class="line">&gt;&gt;&gt; 接收到的参数: [&#x27;...\\__main__.py&#x27;, &#x27;hello&#x27;, &#x27;world&#x27;]</span><br><span class="line">&gt;&gt;&gt; 执行结果: 核心逻辑执行完毕</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong>：</p>
<ul>
<li>当加上 <code>-m</code> 参数时，Python 会先像普通导入一样加载包（执行 <code>__init__</code> 和 <code>core</code>），然后找到 <code>__main__.py</code> 并将其作为脚本执行。</li>
<li>这验证了文中提到的“工程化落地建议”——为包提供 CLI 入口。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Python/" rel="tag"># Python</a>
              <a href="/tags/Import-System/" rel="tag"># Import System</a>
              <a href="/tags/Engineering/" rel="tag"># Engineering</a>
              <a href="/tags/Best-Practices/" rel="tag"># Best Practices</a>
              <a href="/tags/Architecture/" rel="tag"># Architecture</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/12/21/virtualenv/" rel="prev" title="Python包管理全景指南：从venv原理到Mamba最佳实践">
      <i class="fa fa-chevron-left"></i> Python包管理全景指南：从venv原理到Mamba最佳实践
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/12/21/ML%E5%88%9D%E6%AD%A5/" rel="next" title="机器学习理论基石：从PAC学习框架到偏差方差权衡">
      机器学习理论基石：从PAC学习框架到偏差方差权衡 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%8B%86%E8%A7%A3%EF%BC%9A%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">1.</span> <span class="nav-text">1. 基础概念拆解：模块与包的本质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97-Module-%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 什么是模块 (Module)？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%85-Package-%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 什么是包 (Package)？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9F"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 为什么要模块化？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%82%EF%BC%9AImport-%E6%9C%BA%E5%88%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">2. 深入底层：Import 机制是如何工作的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Import-%E7%9A%84%E4%B8%89%E6%AD%A5%E6%9B%B2"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 Import 的三步曲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%EF%BC%9Asys-modules-%E4%B8%8E-sys-path"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 核心组件：sys.modules 与 sys.path</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E7%BB%9D%E5%AF%B9%E5%AF%BC%E5%85%A5-vs-%E7%9B%B8%E5%AF%B9%E5%AF%BC%E5%85%A5"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 绝对导入 vs 相对导入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Package-Module-%E7%AE%A1%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">3.</span> <span class="nav-text">3. Package&#x2F;Module 管理最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9ASrc-Layout"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 目录结构设计：Src Layout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E4%BC%98%E9%9B%85%E7%9A%84%E5%AF%BC%E5%85%A5%E5%86%99%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 优雅的导入写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%BE%AA%E7%8E%AF%E5%AF%BC%E5%85%A5-Circular-Imports-%E7%9A%84%E5%99%A9%E6%A2%A6"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 循环导入 (Circular Imports) 的噩梦</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%B7%A5%E7%A8%8B%E5%8C%96%E8%90%BD%E5%9C%B0%E5%BB%BA%E8%AE%AE"><span class="nav-number">4.</span> <span class="nav-text">4. 工程化落地建议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-init-py-%E7%9A%84%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95%EF%BC%9AFacade-%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 __init__.py 的进阶用法：Facade 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-main-py-%E7%9A%84%E5%A6%99%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 __main__.py 的妙用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5-Dynamic-Import"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 动态导入 (Dynamic Import)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%B8%B8%E8%A7%81%E5%8F%8D%E6%A8%A1%E5%BC%8F-Anti-Patterns"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 常见反模式 (Anti-Patterns)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%A4%BA%E4%BE%8B"><span class="nav-number">6.</span> <span class="nav-text">5. 示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9E%E9%AA%8C%E5%87%86%E5%A4%87%EF%BC%9A%E6%90%AD%E5%BB%BA%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">6.1.</span> <span class="nav-text">1. 实验准备：搭建目录结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81"><span class="nav-number">6.2.</span> <span class="nav-text">2. 编写代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-my-package-core-py"><span class="nav-number">6.2.1.</span> <span class="nav-text">A. my_package&#x2F;core.py</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-my-package-init-py"><span class="nav-number">6.2.2.</span> <span class="nav-text">B. my_package&#x2F;__init__.py</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-my-package-main-py"><span class="nav-number">6.2.3.</span> <span class="nav-text">C. my_package&#x2F;__main__.py</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#D-verify-script-py-%E6%A0%B8%E5%BF%83%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC"><span class="nav-number">6.2.4.</span> <span class="nav-text">D. verify_script.py (核心测试脚本)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%BF%90%E8%A1%8C%E9%AA%8C%E8%AF%81"><span class="nav-number">6.3.</span> <span class="nav-text">3. 运行验证</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E9%AA%8C%E8%AF%81-Import-%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%B0%81%E8%A3%85"><span class="nav-number">6.3.1.</span> <span class="nav-text">实验一：验证 Import 机制与工程封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E9%AA%8C%E8%AF%81-main-py-CLI-%E5%85%A5%E5%8F%A3"><span class="nav-number">6.3.2.</span> <span class="nav-text">实验二：验证 __main__.py (CLI 入口)</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
